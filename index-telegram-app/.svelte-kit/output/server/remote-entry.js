import{get_request_store as e,with_request_store as t}from"@sveltejs/kit/internal/server";import{parse as r}from"devalue";import{error as n,json as o}from"@sveltejs/kit";import{c as s,s as a,a as i}from"./chunks/shared.js";import{B as c}from"./chunks/false.js";import{b as d,a as u,p as f}from"./chunks/environment.js";function m(t,r){if(!r)return e=>{void 0!==e&&n(400,"Bad Request")};if("unchecked"===t)return e=>e;if("~standard"in t)return async r=>{const{event:o,state:s}=e(),a=t["~standard"].validate,i=await a(r);return i.issues&&n(400,await s.handleValidationError({issues:i.issues,event:o})),i.value};throw new Error('Invalid validator passed to remote function. Expected "unchecked" or a Standard Schema (https://standardschema.dev)')}async function p(e,t,r,n,o){if(o&&(await new Promise(e=>setTimeout(e,0)),o.aborted))throw new DOMException("The operation was aborted.","AbortError");const i=s(e,a(t,r.transport));return(r.remote_data??={})[i]??=n()}async function h(e,r,n,o,s,a){const i={...e,setHeaders:()=>{throw new Error("setHeaders is not allowed in remote functions")},cookies:{...e.cookies,set:(t,r,o)=>{if(!n)throw new Error("Cannot set cookies in `query` or `prerender` functions");if(o.path&&!o.path.startsWith("/"))throw new Error("Cookies set in remote functions must have an absolute path");return e.cookies.set(t,r,o)},delete:(t,r)=>{if(!n)throw new Error("Cannot delete cookies in `query` or `prerender` functions");if(r.path&&!r.path.startsWith("/"))throw new Error("Cookies deleted in remote functions must have an absolute path");return e.cookies.delete(t,r)}},route:{id:null},url:new URL(e.url.origin)},c=await t({event:i,state:r},()=>s(o));return t({event:i,state:r},()=>a(c))}function l(t,r){const n=r??t,o=m(t,r),s={type:"command",id:"",name:""},a=t=>{const{event:a,state:i}=e();if(!a.isRemoteRequest)throw new Error(`Cannot call a command (\`${s.name}(${r?"...":""})\`) during server-side rendering`);i.refreshes??={};const c=Promise.resolve(h(a,i,!0,t,o,n));return c.updates=()=>{throw new Error(`Cannot call '${s.name}(...).updates(...)' on the server`)},c};return Object.defineProperty(a,"__",{value:s}),Object.defineProperty(a,"pending",{get:()=>0}),a}function w(t){return function r(n){const o={method:"POST",onsubmit:()=>{}};Object.defineProperty(o,"enhance",{value:()=>({action:o.action,method:o.method,onsubmit:o.onsubmit})});const s={type:"submit",onclick:()=>{}};Object.defineProperty(s,"enhance",{value:()=>({type:"submit",formaction:o.buttonProps.formaction,onclick:()=>{}})}),Object.defineProperty(o,"buttonProps",{value:s});const a={type:"form",name:"",id:"",fn:async r=>{const{event:n,state:o}=e();o.refreshes??={};const s=await h(n,o,!0,r,e=>e,t);return n.isRemoteRequest||((o.remote_data??={})[a.id]=s),s}};return Object.defineProperty(o,"__",{value:a}),Object.defineProperty(o,"action",{get:()=>`?/remote=${a.id}`,enumerable:!0}),Object.defineProperty(s,"formaction",{get:()=>`?/remote=${a.id}`,enumerable:!0}),Object.defineProperty(o,"result",{get(){try{const{remote_data:t}=e().state;return t?.[a.id]}catch{return}}}),Object.defineProperty(o,"pending",{get:()=>0}),Object.defineProperty(s,"pending",{get:()=>0}),null==n&&Object.defineProperty(o,"for",{value:t=>{const{state:n}=e(),o=a.id+"|"+JSON.stringify(t);let s=(n.form_instances??=new Map).get(o);return s||(s=r(t),s.__.id=`${a.id}/${encodeURIComponent(JSON.stringify(t))}`,s.__.name=a.name,n.form_instances.set(o,s)),s}}),o}()}function y(t,f,l){const w="function"==typeof f?f:void 0,y=l??(w?void 0:f),v=w??t,b=m(t,w),g={type:"prerender",id:"",name:"",has_arg:!!w,inputs:y?.inputs,dynamic:y?.dynamic},_=t=>{const f=(async()=>{const{event:f,state:m}=e(),l=a(t,m.transport),w=g.id,y=`${d}/${u}/remote/${w}${l?`/${l}`:""}`;if(!m.prerendering&&!c&&!f.isRemoteRequest)try{return await p(w,t,m,async()=>{const e=await fetch(new URL(y,f.url.origin).href);if(!e.ok)throw new Error("Prerendered response not found");const t=await e.json();return"error"===t.type&&n(t.status,t.error),(m.remote_data??={})[s(w,l)]=t.result,function(e,t){const n={};for(const r in t)n[r]=t[r].decode;return r(e,n)}(t.result,m.transport)})}catch{}if(m.prerendering?.remote_responses.has(y))return m.prerendering.remote_responses.get(y);const _=p(w,t,m,()=>h(f,m,!1,t,b,v));m.prerendering&&m.prerendering.remote_responses.set(y,_);const O=await _;if(m.prerendering){const e={type:"result",result:i(O,m.transport)};m.prerendering.dependencies.set(y,{body:JSON.stringify(e),response:o(e)})}return O})();return f.catch(()=>{}),f};return Object.defineProperty(_,"__",{value:g}),_}function v(t,r){const n=r??t,o=m(t,r),i={type:"query",id:"",name:""},c=t=>{if(f)throw new Error(`Cannot call query '${i.name}' while prerendering, as prerendered pages need static data. Use 'prerender' from $app/server instead`);const{event:r,state:c}=e(),d=new AbortController,u=p(i.id,t,c,()=>h(r,c,!1,t,o,n),d.signal);return u.catch(()=>{}),u.set=r=>{d.abort();const{state:n}=e(),o=n.refreshes;if(!o)throw new Error(`Cannot call set on query '${i.name}' because it is not executed in the context of a command/form remote function`);o[s(i.id,a(t,n.transport))]=Promise.resolve(r)},u.refresh=()=>{const{state:r}=e(),n=r.refreshes;if(!n)throw new Error(`Cannot call refresh on query '${i.name}' because it is not executed in the context of a command/form remote function`);return n[s(i.id,a(t,r.transport))]=u,u.then(()=>{})},u.withOverride=()=>{throw d.abort(),new Error(`Cannot call '${i.name}.withOverride()' on the server`)},u};return Object.defineProperty(c,"__",{value:i}),c}export{l as command,w as form,y as prerender,v as query};
